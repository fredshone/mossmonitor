{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Home","text":""},{"location":"#mossmonitor-mossmonitor","title":"mossmonitor (mossmonitor)","text":""},{"location":"contributing/","title":"Contributing","text":"<p>mossmonitor is an actively maintained and utilised project.</p>"},{"location":"contributing/#how-to-contribute","title":"How to contribute","text":"<p>to report issues, request features, or exchange with our community, just follow the links below.</p> <p>Is something not working?</p> <p> Report a bug</p> <p>Missing information in our docs?</p> <p> Report a docs issue</p> <p>Want to submit an idea?</p> <p> Request a change</p> <p>Have a question or need help?</p> <p> Ask a question</p>"},{"location":"contributing/#developing-mossmonitor","title":"Developing mossmonitor","text":"<p>To find beginner-friendly existing bugs and feature requests you may like to start out with, take a look at our good first issues.</p>"},{"location":"contributing/#setting-up-a-development-environment","title":"Setting up a development environment","text":"<p>To create a development environment for mossmonitor, with all libraries required for development and quality assurance installed, it is easiest to install mossmonitor using the mamba package manager, as follows:</p> <ol> <li>Install mamba with the Mambaforge executable for your operating system.</li> <li>Open the command line (or the \"miniforge prompt\" in Windows).</li> <li>Download (a.k.a., clone) the mossmonitor repository: <code>git clone git@github.com:fredshone/mossmonitor.git</code></li> <li>Change into the <code>mossmonitor</code> directory: <code>cd mossmonitor</code></li> <li>Create the mossmonitor mamba environment: <code>mamba create -n mossmonitor -c conda-forge --file requirements/base.txt --file requirements/dev.txt</code></li> <li>Activate the mossmonitor mamba environment: <code>mamba activate mossmonitor</code></li> <li>Install the mossmonitor package into the environment, in editable mode and ignoring dependencies (we have dealt with those when creating the mamba environment): <code>pip install --no-deps -e .</code></li> </ol> <p>All together:</p> <pre><code>git clone git@github.com:fredshone/mossmonitor.git\ncd mossmonitor\nmamba create -n mossmonitor -c conda-forge --file requirements/base.txt --file requirements/dev.txt\nmamba activate mossmonitor\npip install --no-deps -e .\n</code></pre> <p>If installing directly with pip, you can install these libraries using the <code>dev</code> option, i.e., <code>pip install -e '.[dev]'</code> Either way, you should add your environment as a jupyter kernel, so the example notebooks can run in the tests: <code>ipython kernel install --user --name=mossmonitor</code> If you plan to make changes to the code then please make regular use of the following tools to verify the codebase while you work:</p> <ul> <li><code>pre-commit</code>: run <code>pre-commit install</code> in your command line to load inbuilt checks that will run every time you commit your changes. The checks are: 1. check no large files have been staged, 2. lint python files for major errors, 3. format python files to conform with the PEP8 standard. You can also run these checks yourself at any time to ensure staged changes are clean by calling <code>pre-commit</code>.</li> <li><code>pytest</code> - run the unit test suite and check test coverage.</li> </ul> <p>Note</p> <p>If you already have an environment called <code>mossmonitor</code> on your system (e.g., for a stable installation of the package), you will need to chose a different environment name. You will then need to add this as a pytest argument when running the tests: <code>pytest --nbmake-kernel=[my-env-name]</code>.</p>"},{"location":"contributing/#rapid-fire-testing","title":"Rapid-fire testing","text":"<p>The following options allow you to strip down the test suite to the bare essentials: 1. The test suite includes unit tests and integration tests (in the form of jupyter notebooks found in the <code>examples</code> directory). The integration tests can be slow, so if you want to avoid them during development, you should run <code>pytest tests/</code>. 2. You can avoid generating coverage reports, by adding the <code>--no-cov</code> argument: <code>pytest --no-cov</code>. 3. By default, the tests run with up to two parallel threads, to increase this to e.g. 4 threads: <code>pytest -n4</code>.</p> <p>All together:</p> <pre><code>pytest tests/ --no-cov -n4\n</code></pre> <p>Note</p> <p>You cannot debug failing tests and have your tests run in parallel, you will need to set <code>-n0</code> if using the <code>--pdb</code> flag</p>"},{"location":"contributing/#memory-profiling","title":"Memory profiling","text":"<p>Note</p> <p>When you open a pull request (PR), one of the GitHub actions will run memory profiling for you. This means you don't have to do any profiling locally. However, if you can, it is still good practice to do so as you will catch issues earlier.</p> <p>mossmonitor can be memory intensive; we like to ensure that any development to the core code does not exacerbate this. If you are running on a UNIX device (i.e., not on Windows), you can test whether any changes you have made adversely impact memory and time performance as follows:</p> <ol> <li>Install memray in your <code>mossmonitor</code> mamba environment: <code>mamba install memray pytest-memray</code>.</li> <li>Run the memory profiling integration test: <code>pytest -p memray -m \"high_mem\" --no-cov</code>.</li> <li>Optionally, to visualise the memory allocation, run <code>pytest -p memray -m \"high_mem\" --no-cov --memray-bin-path=[my_path] --memray-bin-prefix=[my_prefix]</code> - where you must define <code>[my_path]</code> and <code>[my_prefix]</code> - followed by <code>memray flamegraph [my_path]/[my_prefix]-tests-test_100_memory_profiling.py-test_mem.bin</code>. You will then find the HTML report at <code>[my_path]/memray-flamegraph-[my_prefix]-tests-test_100_memory_profiling.py-test_mem.html</code>.</li> </ol> <p>All together:</p> <pre><code>mamba install memray pytest-memray\npytest -p memray -m \"high_mem\" --no-cov --memray-bin-path=[my_path] --memray-bin-prefix=[my_prefix]\nmemray flamegraph [my_path]/[my_prefix]-tests-test_100_memory_profiling.py-test_mem.bin\n</code></pre> <p>For more information on using memray, refer to their documentation.</p>"},{"location":"contributing/#submitting-changes","title":"Submitting changes","text":"<p>To contribute changes:</p> <ol> <li>Fork the project on GitHub.</li> <li>Create a feature branch to work on in your fork (<code>git checkout -b new-fix-or-feature</code>).</li> <li>Test your changes using <code>pytest</code>.</li> <li>Commit your changes to the feature branch (you should have <code>pre-commit</code> installed to ensure your code is correctly formatted when you commit changes).</li> <li>Push the branch to GitHub (<code>git push origin new-fix-or-feature</code>).</li> <li>On GitHub, create a new pull request from the feature branch.</li> </ol>"},{"location":"contributing/#pull-requests","title":"Pull requests","text":"<p>Before submitting a pull request, check whether you have:</p> <ul> <li>Added your changes to <code>CHANGELOG.md</code>.</li> <li>Added or updated documentation for your changes.</li> <li>Added tests if you implemented new functionality.</li> </ul> <p>When opening a pull request, please provide a clear summary of your changes!</p>"},{"location":"contributing/#commit-messages","title":"Commit messages","text":"<p>Please try to write clear commit messages. One-line messages are fine for small changes, but bigger changes should look like this:</p> <pre><code>A brief summary of the commit (max 50 characters)\n\nA paragraph or bullet-point list describing what changed and its impact,\ncovering as many lines as needed.\n</code></pre>"},{"location":"contributing/#code-conventions","title":"Code conventions","text":"<p>Start reading our code and you'll get the hang of it.</p> <p>We mostly follow the official Style Guide for Python Code (PEP8).</p> <p>We have chosen to use the uncompromising code formatter <code>black</code> and the linter <code>ruff</code>. When run from the root directory of this repo, <code>pyproject.toml</code> should ensure that formatting and linting fixes are in line with our custom preferences (e.g., 100 character maximum line length). The philosophy behind using <code>black</code> is to have uniform style throughout the project dictated by code. Since <code>black</code> is designed to minimise diffs, and make patches more human readable, this also makes code reviews more efficient. To make this a smooth experience, you should run <code>pre-commit install</code> after setting up your development environment, so that <code>black</code> makes all the necessary fixes to your code each time you commit, and so that <code>ruff</code> will highlight any errors in your code. If you prefer, you can also set up your IDE to run these two tools whenever you save your files, and to have <code>ruff</code> highlight erroneous code directly as you type. Take a look at their documentation for more information on configuring this.</p> <p>We require all new contributions to have docstrings for all modules, classes and methods. When adding docstrings, we request you use the Google docstring style.</p>"},{"location":"contributing/#release-checklist","title":"Release checklist","text":""},{"location":"contributing/#pre-release","title":"Pre-release","text":"<ul> <li> Make sure all unit and integration tests pass (This is best done by creating a pre-release pull request).</li> <li> Re-run tutorial Jupyter notebooks (<code>pytest examples/ --overwrite</code>).</li> <li> Make sure documentation builds without errors (<code>mike deploy [version]</code>, where <code>[version]</code> is the current minor release of the form <code>X.Y</code>).</li> <li> Make sure the changelog is up-to-date, especially that new features and backward incompatible changes are clearly marked.</li> </ul>"},{"location":"contributing/#create-release","title":"Create release","text":"<ul> <li> Bump the version number in <code>mossmonitor/__init__.py</code></li> <li> Update the changelog with final version number of the form <code>vX.Y.Z</code>, release date, and github <code>compare</code> link (at the bottom of the page).</li> <li> Commit with message <code>Release vX.Y.Z</code>, then add a <code>vX.Y.Z</code> tag.</li> <li> Create a release pull request to verify that the conda package builds successfully.</li> <li> Once the PR is approved and merged, create a release through the GitHub web interface, using the same tag, titling it <code>Release vX.Y.Z</code> and include all the changelog elements that are not flagged as internal.</li> </ul>"},{"location":"contributing/#post-release","title":"Post-release","text":"<ul> <li> Update the changelog, adding a new <code>[Unreleased]</code> heading.</li> <li> Update <code>mossmonitor/__init__.py</code> to the next version appended with <code>.dev0</code>, in preparation for the next main commit.</li> </ul>"},{"location":"installation/","title":"Installation","text":""},{"location":"installation/#setting-up-a-user-environment","title":"Setting up a user environment","text":"<p>As a <code>mossmonitor</code> user, it is easiest to install using the mamba package manager, as follows:</p> <ol> <li>Install mamba with the Mambaforge executable for your operating system.</li> <li> <p>Open the command line (or the \"miniforge prompt\" in Windows).</p> </li> <li> <p>Create the mossmonitor mamba environment: <code>mamba create -n mossmonitor -c conda-forge -c fredshone mossmonitor</code></p> </li> <li>Activate the mossmonitor mamba environment: <code>mamba activate mossmonitor</code></li> </ol> <p>All together:</p> <p>WIP</p>"},{"location":"installation/#running-the-example-notebooks","title":"Running the example notebooks","text":"<p>If you have followed the non-developer installation instructions above, you will need to install <code>jupyter</code> into your <code>mossmonitor</code> environment to run the example notebooks:</p> <pre><code>mamba install -n mossmonitor jupyter\n</code></pre> <p>With Jupyter installed, it's easiest to then add the environment as a jupyter kernel:</p> <pre><code>mamba activate mossmonitor\nipython kernel install --user --name=mossmonitor\njupyter notebook\n</code></pre>"},{"location":"installation/#choosing-a-different-environment-name","title":"Choosing a different environment name","text":"<p>If you would like to use a different name to <code>mossmonitor</code> for your mamba environment, the installation becomes (where <code>[my-env-name]</code> is your preferred name for the environment):</p> <pre><code>mamba create -n [my-env-name] -c conda-forge --file requirements/base.txt\nmamba activate [my-env-name]\nipython kernel install --user --name=[my-env-name]\n</code></pre>"},{"location":"installation/#setting-up-a-development-environment","title":"Setting up a development environment","text":"<p>The install instructions are slightly different to create a development environment compared to a user environment:</p> <pre><code>git clone git@github.com:fredshone/mossmonitor.git\ncd mossmonitor\nmamba create -n mossmonitor -c conda-forge --file requirements/base.txt --file requirements/dev.txt\nmamba activate mossmonitor\npip install --no-deps -e .\n</code></pre> <p>For more detailed installation instructions specific to developing the mossmonitor codebase, see our development documentation.</p>"},{"location":"api/cli/","title":"CLI Reference","text":"<p>This page provides documentation for our command line tools.</p>"},{"location":"api/cli/#mossmonitor","title":"mossmonitor","text":"<p>Console script for mossmonitor.</p> <p>Usage:</p> <pre><code>mossmonitor [OPTIONS]\n</code></pre> <p>Options:</p> Name Type Description Default <code>--version</code> boolean Show the version and exit. <code>False</code> <code>--help</code> boolean Show this message and exit. <code>False</code>"},{"location":"examples/1_intro_to_mossmonitor/","title":"Test","text":"In\u00a0[2]: Copied! <pre>import cv2\nimport random\nimport numpy as np\nfrom matplotlib import pyplot as plt\nimport matplotlib.gridspec as gridspec\n</pre> import cv2 import random import numpy as np from matplotlib import pyplot as plt import matplotlib.gridspec as gridspec In\u00a0[3]: Copied! <pre>image = cv2.imread(\"assets/test.jpg\")\nplt.figure(figsize=(10, 10))\nplt.imshow(cv2.cvtColor(image, cv2.COLOR_BGR2RGB), interpolation=\"nearest\")\n</pre> image = cv2.imread(\"assets/test.jpg\") plt.figure(figsize=(10, 10)) plt.imshow(cv2.cvtColor(image, cv2.COLOR_BGR2RGB), interpolation=\"nearest\") Out[3]: <pre>&lt;matplotlib.image.AxesImage at 0x20e7b7295b0&gt;</pre> In\u00a0[31]: Copied! <pre>template = image.copy()\ntemplate = template[290:870, 862:1000, :]\ntemplate = cv2.cvtColor(template, cv2.COLOR_BGR2GRAY)\n(thresh, template) = cv2.threshold(template, 128, 255, cv2.THRESH_BINARY | cv2.THRESH_OTSU)\nprint(thresh)\nh, w = template.shape\nplt.figure(figsize=(10, 10))\nplt.imshow(template, cmap=\"gray\", interpolation=\"nearest\")\n</pre> template = image.copy() template = template[290:870, 862:1000, :] template = cv2.cvtColor(template, cv2.COLOR_BGR2GRAY) (thresh, template) = cv2.threshold(template, 128, 255, cv2.THRESH_BINARY | cv2.THRESH_OTSU) print(thresh) h, w = template.shape plt.figure(figsize=(10, 10)) plt.imshow(template, cmap=\"gray\", interpolation=\"nearest\") <pre>115.0\n</pre> Out[31]: <pre>&lt;matplotlib.image.AxesImage at 0x20e014324b0&gt;</pre> In\u00a0[5]: Copied! <pre>def recolour(image):\n    delta_v = random.randint(-50, 50)\n    delta_s = random.randint(-50, 50)\n    delta_h = random.randint(-10, 10)\n    hsv = cv2.cvtColor(image, cv2.COLOR_BGR2HSV)\n    hsv[:, :, 2] = cv2.add(hsv[:, :, 2], delta_v)\n    hsv[:, :, 1] = cv2.add(hsv[:, :, 1], delta_s)\n    hsv[:, :, 0] = cv2.add(hsv[:, :, 0], delta_h)\n    img = cv2.cvtColor(hsv, cv2.COLOR_HSV2BGR)\n    return img\n\n\ndef wobble(img, ang_range, shear_range, trans_range):\n    # Rotation\n    ang_rot = np.random.uniform(ang_range) - ang_range / 2\n    rows, cols, ch = img.shape\n    Rot_M = cv2.getRotationMatrix2D((cols / 2, rows / 2), ang_rot, 1)\n\n    # Translation\n    tr_x = trans_range * np.random.uniform() - trans_range / 2\n    tr_y = trans_range * np.random.uniform() - trans_range / 2\n    Trans_M = np.float32([[1, 0, tr_x], [0, 1, tr_y]])\n\n    # Shear\n    pts1 = np.float32([[5, 5], [20, 5], [5, 20]])\n    pt1 = 5 + shear_range * np.random.uniform() - shear_range / 2\n    pt2 = 20 + shear_range * np.random.uniform() - shear_range / 2\n\n    pts2 = np.float32([[pt1, 5], [pt2, pt1], [5, pt2]])\n    shear_M = cv2.getAffineTransform(pts1, pts2)\n    img = cv2.warpAffine(img, Rot_M, (cols, rows))\n    img = cv2.warpAffine(img, Trans_M, (cols, rows))\n    img = cv2.warpAffine(img, shear_M, (cols, rows))\n\n    # Brightness\n    img = recolour(img)\n\n    return img\n\n\ndef plot_grid(images, figsize=(10, 10)):\n    N = len(images)\n    n = int(np.sqrt(N))\n    gs1 = gridspec.GridSpec(n, n)\n    gs1.update(wspace=0.02, hspace=0.02)  # set the spacing between axes.\n    plt.figure(figsize=figsize)\n    for i, img in enumerate(images):\n        ax1 = plt.subplot(gs1[i])\n        ax1.set_xticklabels([])\n        ax1.set_yticklabels([])\n        ax1.set_aspect(\"equal\")\n        plt.subplot(n, n, i + 1)\n        plt.imshow(cv2.cvtColor(img, cv2.COLOR_BGR2RGB))\n        plt.axis(\"off\")\n\n    plt.show()\n\n\ncandidates = [wobble(image.copy(), 2, 2, 2) for _ in range(16)]\nplot_grid(candidates, figsize=(10, 10))\n</pre> def recolour(image):     delta_v = random.randint(-50, 50)     delta_s = random.randint(-50, 50)     delta_h = random.randint(-10, 10)     hsv = cv2.cvtColor(image, cv2.COLOR_BGR2HSV)     hsv[:, :, 2] = cv2.add(hsv[:, :, 2], delta_v)     hsv[:, :, 1] = cv2.add(hsv[:, :, 1], delta_s)     hsv[:, :, 0] = cv2.add(hsv[:, :, 0], delta_h)     img = cv2.cvtColor(hsv, cv2.COLOR_HSV2BGR)     return img   def wobble(img, ang_range, shear_range, trans_range):     # Rotation     ang_rot = np.random.uniform(ang_range) - ang_range / 2     rows, cols, ch = img.shape     Rot_M = cv2.getRotationMatrix2D((cols / 2, rows / 2), ang_rot, 1)      # Translation     tr_x = trans_range * np.random.uniform() - trans_range / 2     tr_y = trans_range * np.random.uniform() - trans_range / 2     Trans_M = np.float32([[1, 0, tr_x], [0, 1, tr_y]])      # Shear     pts1 = np.float32([[5, 5], [20, 5], [5, 20]])     pt1 = 5 + shear_range * np.random.uniform() - shear_range / 2     pt2 = 20 + shear_range * np.random.uniform() - shear_range / 2      pts2 = np.float32([[pt1, 5], [pt2, pt1], [5, pt2]])     shear_M = cv2.getAffineTransform(pts1, pts2)     img = cv2.warpAffine(img, Rot_M, (cols, rows))     img = cv2.warpAffine(img, Trans_M, (cols, rows))     img = cv2.warpAffine(img, shear_M, (cols, rows))      # Brightness     img = recolour(img)      return img   def plot_grid(images, figsize=(10, 10)):     N = len(images)     n = int(np.sqrt(N))     gs1 = gridspec.GridSpec(n, n)     gs1.update(wspace=0.02, hspace=0.02)  # set the spacing between axes.     plt.figure(figsize=figsize)     for i, img in enumerate(images):         ax1 = plt.subplot(gs1[i])         ax1.set_xticklabels([])         ax1.set_yticklabels([])         ax1.set_aspect(\"equal\")         plt.subplot(n, n, i + 1)         plt.imshow(cv2.cvtColor(img, cv2.COLOR_BGR2RGB))         plt.axis(\"off\")      plt.show()   candidates = [wobble(image.copy(), 2, 2, 2) for _ in range(16)] plot_grid(candidates, figsize=(10, 10)) In\u00a0[32]: Copied! <pre>results = []\nfor img in candidates:\n    bw_img = cv2.cvtColor(img, cv2.COLOR_BGR2GRAY)\n    (thresh, bw_img) = cv2.threshold(bw_img, 128, 255, cv2.THRESH_BINARY | cv2.THRESH_OTSU)\n    res = cv2.matchTemplate(bw_img, template, cv2.TM_CCOEFF_NORMED)\n    threshold = 0.7\n    loc = np.where(res &gt;= threshold)\n    _img = img.copy()\n    for pt in zip(*loc[::-1]):\n        cv2.rectangle(_img, pt, (pt[0] + w, pt[1] + h), (0, 0, 255), 2)\n    results.append(_img)\n\nplot_grid(results, figsize=(10, 10))\n</pre> results = [] for img in candidates:     bw_img = cv2.cvtColor(img, cv2.COLOR_BGR2GRAY)     (thresh, bw_img) = cv2.threshold(bw_img, 128, 255, cv2.THRESH_BINARY | cv2.THRESH_OTSU)     res = cv2.matchTemplate(bw_img, template, cv2.TM_CCOEFF_NORMED)     threshold = 0.7     loc = np.where(res &gt;= threshold)     _img = img.copy()     for pt in zip(*loc[::-1]):         cv2.rectangle(_img, pt, (pt[0] + w, pt[1] + h), (0, 0, 255), 2)     results.append(_img)  plot_grid(results, figsize=(10, 10)) In\u00a0[34]: Copied! <pre>def check_clear(candidates, proposed, w, h):\n    for pt in candidates:\n        if pt[0] - w &lt; proposed[0] &lt; pt[0] + w and pt[1] - h &lt; proposed[1] &lt; pt[1] + h:\n            return False\n    return True\n\n\nresults = []\nfor img in candidates:\n    bw_img = cv2.cvtColor(img, cv2.COLOR_BGR2GRAY)\n    (thresh, bw_img) = cv2.threshold(bw_img, 128, 255, cv2.THRESH_BINARY | cv2.THRESH_OTSU)\n    res = cv2.matchTemplate(bw_img, template, cv2.TM_CCOEFF_NORMED)\n    threshold = 0.5\n    topk = 3\n    loc = np.where(res &gt;= threshold)\n    h, w = template.shape\n    _img = img.copy()\n    hits = []\n    for pt in zip(*loc[::-1]):\n        if check_clear(hits, pt, w, h):\n            hits.append(pt)\n            cv2.rectangle(_img, pt, (pt[0] + w, pt[1] + h), (0, 0, 255), 10)\n            if len(hits) == topk:\n                break\n    results.append(_img)\n\nplot_grid(results, figsize=(10, 10))\n</pre> def check_clear(candidates, proposed, w, h):     for pt in candidates:         if pt[0] - w &lt; proposed[0] &lt; pt[0] + w and pt[1] - h &lt; proposed[1] &lt; pt[1] + h:             return False     return True   results = [] for img in candidates:     bw_img = cv2.cvtColor(img, cv2.COLOR_BGR2GRAY)     (thresh, bw_img) = cv2.threshold(bw_img, 128, 255, cv2.THRESH_BINARY | cv2.THRESH_OTSU)     res = cv2.matchTemplate(bw_img, template, cv2.TM_CCOEFF_NORMED)     threshold = 0.5     topk = 3     loc = np.where(res &gt;= threshold)     h, w = template.shape     _img = img.copy()     hits = []     for pt in zip(*loc[::-1]):         if check_clear(hits, pt, w, h):             hits.append(pt)             cv2.rectangle(_img, pt, (pt[0] + w, pt[1] + h), (0, 0, 255), 10)             if len(hits) == topk:                 break     results.append(_img)  plot_grid(results, figsize=(10, 10))  In\u00a0[\u00a0]: Copied! <pre>\n</pre>"},{"location":"examples/1_intro_to_mossmonitor/#test","title":"Test\u00b6","text":"<p>Templating demo using test image. templating is used to identify parts of the image that contain moss based on a template.</p>"},{"location":"CHANGELOG/","title":"Changelog","text":""},{"location":"CHANGELOG/#changelog","title":"Changelog","text":"<p>All notable changes to this project will be documented in this file.</p> <p>The format is based on Keep a Changelog, and this project adheres to Semantic Versioning.</p>"},{"location":"CHANGELOG/#unreleased","title":"Unreleased","text":""},{"location":"CHANGELOG/#fixed","title":"Fixed","text":""},{"location":"CHANGELOG/#added","title":"Added","text":""},{"location":"CHANGELOG/#changed","title":"Changed","text":""},{"location":"CHANGELOG/#removed","title":"Removed","text":""},{"location":"CHANGELOG/#v010-2024-07-22","title":"[v0.1.0] - 2024-07-22","text":"<p>Initial release.</p>"},{"location":"reference/mossmonitor/core/","title":"mossmonitor.core","text":"<p>Main module.</p>"}]}